<title>GWF Co Author Graph</title>
<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css">
<!-- START SIGMA IMPORTS -->
<script src="gwf_co_author_graph/build/sigma.min.js"></script>
<script src="gwf_co_author_graph/src/sigma.core.js"></script>
<script src="gwf_co_author_graph/src/conrad.js"></script>
<script src="gwf_co_author_graph/src/utils/sigma.utils.js"></script>
<script src="gwf_co_author_graph/src/utils/sigma.polyfills.js"></script>
<script src="gwf_co_author_graph/src/sigma.settings.js"></script>
<script src="gwf_co_author_graph/src/classes/sigma.classes.dispatcher.js"></script>
<script src="gwf_co_author_graph/src/classes/sigma.classes.configurable.js"></script>
<script src="gwf_co_author_graph/src/classes/sigma.classes.graph.js"></script>
<script src="gwf_co_author_graph/src/classes/sigma.classes.camera.js"></script>
<script src="gwf_co_author_graph/src/classes/sigma.classes.quad.js"></script>
<script src="gwf_co_author_graph/src/classes/sigma.classes.edgequad.js"></script>
<script src="gwf_co_author_graph/rc/captors/sigma.captors.mouse.js"></script>
<script src="gwf_co_author_graph/src/captors/sigma.captors.touch.js"></script>
<script src="gwf_co_author_graph/src/renderers/sigma.renderers.canvas.js"></script>
<script src="gwf_co_author_graph/src/renderers/sigma.renderers.webgl.js"></script>
<script src="gwf_co_author_graph/src/renderers/sigma.renderers.svg.js"></script>
<script src="gwf_co_author_graph/src/renderers/sigma.renderers.def.js"></script>
<script src="gwf_co_author_graph/src/renderers/webgl/sigma.webgl.nodes.def.js"></script>
<script src="gwf_co_author_graph/src/renderers/webgl/sigma.webgl.nodes.fast.js"></script>
<script src="gwf_co_author_graph/src/renderers/webgl/sigma.webgl.edges.def.js"></script>
<script src="gwf_co_author_graph/src/renderers/webgl/sigma.webgl.edges.fast.js"></script>
<script src="gwf_co_author_graph/src/renderers/webgl/sigma.webgl.edges.arrow.js"></script>
<script src="gwf_co_author_graph/src/renderers/canvas/sigma.canvas.labels.def.js"></script>
<script src="gwf_co_author_graph/src/renderers/canvas/sigma.canvas.hovers.def.js"></script>
<script src="gwf_co_author_graph/src/renderers/canvas/sigma.canvas.nodes.def.js"></script>
<script src="gwf_co_author_graph/src/renderers/canvas/sigma.canvas.edges.def.js"></script>
<script src="gwf_co_author_graph/src/renderers/canvas/sigma.canvas.edges.curve.js"></script>
<script src="gwf_co_author_graph/src/renderers/canvas/sigma.canvas.edges.arrow.js"></script>
<script src="gwf_co_author_graph/src/renderers/canvas/sigma.canvas.edges.curvedArrow.js"></script>
<script src="gwf_co_author_graph/src/renderers/canvas/sigma.canvas.edgehovers.def.js"></script>
<script src="gwf_co_author_graph/src/renderers/canvas/sigma.canvas.edgehovers.curve.js"></script>
<script src="gwf_co_author_graph/src/renderers/canvas/sigma.canvas.edgehovers.arrow.js"></script>
<script src="gwf_co_author_graph/src/renderers/canvas/sigma.canvas.edgehovers.curvedArrow.js"></script>
<script src="gwf_co_author_graph/src/renderers/canvas/sigma.canvas.extremities.def.js"></script>
<script src="gwf_co_author_graph/src/renderers/svg/sigma.svg.utils.js"></script>
<script src="gwf_co_author_graph/src/renderers/svg/sigma.svg.nodes.def.js"></script>
<script src="gwf_co_author_graph/src/renderers/svg/sigma.svg.edges.def.js"></script>
<script src="gwf_co_author_graph/src/renderers/svg/sigma.svg.edges.curve.js"></script>
<script src="gwf_co_author_graph/src/renderers/svg/sigma.svg.labels.def.js"></script>
<script src="gwf_co_author_graph/src/renderers/svg/sigma.svg.hovers.def.js"></script>
<script src="gwf_co_author_graph/src/middlewares/sigma.middlewares.rescale.js"></script>
<script src="gwf_co_author_graph/src/middlewares/sigma.middlewares.copy.js"></script>
<script src="gwf_co_author_graph/src/misc/sigma.misc.animation.js"></script>
<script src="gwf_co_author_graph/src/misc/sigma.misc.bindEvents.js"></script>
<script src="gwf_co_author_graph/src/misc/sigma.misc.bindDOMEvents.js"></script>
<script src="gwf_co_author_graph/src/misc/sigma.misc.drawHovers.js"></script>
<!-- END SIGMA IMPORTS -->
<script src="gwf_co_author_graph/plugins/sigma.parsers.gexf/gexf-parser.js"></script>
<script src="gwf_co_author_graph/plugins/sigma.parsers.gexf/sigma.parsers.gexf.js"></script>
<script src="plugins/sigma.renderers.customShapes/shape-library.js"></script>
<script src="plugins/sigma.renderers.customShapes/sigma.renderers.customShapes.js"></script>
<script src="https://d3js.org/d3-dsv.v1.min.js"></script>
<script src="https://d3js.org/d3-fetch.v1.min.js"></script>
<!-- Add icon library -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">

<nav class="navbar navbar-dark bg-primary">
  <a class="navbar-brand" href="index.html">
    Global Water Futures
  </a>
  <div class="node-controls navbar-right">
    <div class="search-container" style="float: right;">
      <div class="input-group">
        <input id="search-input" class="form-control border-end-0 border" list="nodes-datalist"
          placeholder="Search for an author" size="40px">
        <span class="input-group-append">
          <button class="btn btn-outline-secondary bg-white border-start-0 border-bottom-0 border ms-n5" type="button">
            <i class="fa fa-search"></i>
          </button>
        </span>
      </div>
    </div>
    <datalist id="nodes-datalist"></datalist>
  </div>
</nav>
<div class="container p-3 my-3"
  style="float: left; width: 320px; height: 70%; position: relative; z-index: 20; align-self: flex-end;">
  <div
    style="border: solid; padding: 10px; margin-left:2px; margin-right: 0px; box-shadow: 5px 10px 8px #888888; border-width: 1px; border-radius: 25px; background-color: white;">
    <h3 class="centre">Global Water Futures Co-Author
      Graph</h3>
    <hr>
    <p>
      This co-author graph shows a visualization of common author collaborations in the GWF community.<br><br>
      It is an undirected graph with <b>nodes</b> representing authors and <b>edges</b> showing co-authorship. <br><br>
      The node sizes
      are scaled with the number of gwf publications.
    </p>
    <img src="gwf_co_author_graph/file/images/img01.png" width="250px">
  </div>
  <div style="margin-top: 30px;" class="text-center">
    <style>
      .zoom-button {
        position: relative;
        cursor: pointer;
        z-index: 10;
        color: #222a2a;
        background-color: white;
        font-size: 20px;
        border-style: solid;
        border-width: 1px;
        border-color: #222a2a;
        align-self: flex-end;
        width: 60px;
        height: 60px;
      }
    </style>
    <button type="button" id="zoom-in-button" class="zoom-button zoom-in"><i class="fa fa-search-plus"></i></button>
    <button type="button" id="zoom-out-button" class="zoom-button zoom-out"><i class="fa fa-search-minus"></i></button>
    <button type="button" id="refresh-button" class="zoom-button refresh" onClick="window.location.reload();">
      <i class="fa fa-refresh"></i>
    </button>
  </div>
</div>

<span id="selected-nodes" class="btn btn-danger"
  style="margin-top: 5px; margin-right:13px ; z-index: 25; float: right; position: relative;"></span>
<div id="container">
  <style>
    #sigma-container {
      top: 55px;
      bottom: 0;
      left: 0px;
      right: 0;
      position: absolute;
    }
  </style>
  <div id="sigma-container"></div>
</div>
<script>
  /**
   * Here is just a basic example on how to properly display a graph
   * exported from Gephi in the GEXF format.
   *
   * The plugin sigma.parsers.gexf can load and parse the GEXF graph file,
   * and instantiate sigma when the graph is received.
   *
   * The object given as the second parameter is the base of the instance
   * configuration object. The plugin will just add the "graph" key to it
   * before the instanciation.
   */

  var selected = [];

  sigma.classes.graph.addMethod('neighbors', function (nodeId) {
    var k,
      neighbors = {},
      index = this.allNeighborsIndex[nodeId] || {};

    for (k in index)
      neighbors[k] = this.nodesIndex[k];

    return neighbors;
  });

  var s = new sigma({
    renderers: [
      {
        type: 'canvas',
        container: document.getElementById('sigma-container'),
        freeStyle: true
      }
    ],
    settings: {
      autoRescale: true,
      borderSize: 6,
      defaultEdgeColor: '#B1B1B1',
      edgeColor: 'default',
      minNodeSize: 0.2,
      maxNodeSize: 25,
      labelThreshold: 15,
      labelSize: "proportional",
      defaultNodeBorderColor: "#FFF"
    }
  })

  sigma.parsers.gexf('gwf_co_author_graph/file/data/graph2.gexf',
    s,
    function (s) {
      // We first need to save the original colors of our
      // nodes and edges, like this:
      s.graph.nodes().forEach(function (n) {
        n.originalColor = n.color;
        n.originalLabel = n.label;
      });

      s.graph.edges().forEach(function (e) {
        e.originalColor = e.color;
      });

      // When a node is clicked, we check for each node
      // if it is a neighbor of the clicked one. If not,
      // we set its color as grey, and else, it takes its
      // original color.
      // We do the same for the edges, and we only keep
      // edges that have both extremities colored.
      s.bind('clickNode', function (e) {

        s.graph.nodes().forEach(function (n) {
          n.color = n.originalColor;
          n.label = n.originalLabel;
        });

        var selected = [];

        selected[e.data.node.id] = e.data.node;
        showSelectedNodes(selected);

        var nodeId = e.data.node.id,
          toKeep = s.graph.neighbors(nodeId);
        toKeep[nodeId] = e.data.node;

        s.graph.nodes().forEach(function (n) {
          if (toKeep[n.id]) {
            n.color = n.originalColor;
          } else {
            n.color = '#eee';
            n.label = "";
          }
        });

        s.graph.edges().forEach(function (e) {
          if (toKeep[e.source] && toKeep[e.target]) {
            e.color = e.originalColor;
          } else {
            e.color = '#FFF';
          }
        });

        e.data.node.color = '#d9534f'

        // Since the data has been modified, we need to
        // call the refresh method to make the colors
        // update effective.
        s.refresh();
      });

      // When the stage is clicked, we just color each
      // node and edge with its original color.
      s.bind('clickStage', function (e) {
        s.graph.nodes().forEach(function (n) {
          n.color = n.originalColor;
          n.label = n.originalLabel;
        });

        s.graph.edges().forEach(function (e) {
          e.color = e.originalColor;
        });
        document.getElementById('search-input').value = "";
        // Same as in the previous event:
        s.refresh();
      });
      s.refresh();
      populateSearchList(s.graph.nodes());

      // Add event listeners to buttons
      var inputBox = document.getElementById('search-input');
      inputBox.addEventListener("change", searchChange);

      var zoomInButton = document.getElementById('zoom-in-button');
      zoomInButton.addEventListener("click", zoomIn);
      var zoomOutButton = document.getElementById('zoom-out-button');
      zoomOutButton.addEventListener("click", zoomOut);
    });

  function searchChange(e) {
    s.graph.nodes().forEach(function (n) {
      n.color = n.originalColor;
      n.label = n.originalLabel;
    });
    var selected = [];
    var value = e.target.value;

    // Add node to selected
    s.graph.nodes().forEach(function (n) {
      if (n.label == value) {
        if (!selected[n.id]) {
          selected[n.id] = n;
          var c = s.camera;
          sigma.misc.animation.camera(c, {
            x: n['read_cam0:x'], y: n['read_cam0:y'],
            ratio: c.ratio / c.settings('zoomingRatio')
          }, {
            duration: 700
          });
        }
      }
    });
    nodeSelect(s, selected);
  }

  function refresh() {
    s.refresh();
  }

  function zoomIn() {
    var c = s.camera;
    sigma.misc.animation.camera(c, {
      ratio: c.ratio / c.settings('zoomingRatio')
    }, {
      duration: 700
    });
  }

  function zoomOut() {
    var c = s.camera;
    sigma.misc.animation.camera(c, {
      ratio: c.ratio * c.settings('zoomingRatio')
    }, {
      duration: 700
    });
  }

  function populateSearchList(nodes) {
    var container = document.getElementById('nodes-datalist');
    nodes.forEach(function (n) {
      var item = document.createElement('option');
      item.value = n.label;
      container.appendChild(item);
    });
  }

  getColor = {
    "0": "#F012BE",
    "1": "#85144b",
    "2": "#2ECC40",
    "3": "#a9a9a9",
    "4": "#33805d",
    "5": "#222a2a",
    "6": "#FF4136",
    "7": "#001F3F",
    "8": "#FFDC00",
    "9": "#FF851B ",
  };

  // Show all selected nodes next to the notes for quick reference
  function showSelectedNodes(selected) {
    // Remove old selecteed nodes
    document.querySelectorAll('.selected-node').forEach(function (a) {
      a.remove()
    });

    if (Object.keys(selected).length > 0) {
      var selected_container = document.getElementById('selected-nodes');
      Object.keys(selected).forEach(function (key) {
        var selected_item = document.createElement("div");
        selected_item.classList.add('selected-node');
        selected_item.innerHTML = selected[key].label;
        selected_container.appendChild(selected_item);
      });
    }
  }

  // Toggle select a node
  function nodeSelect(s, selected) {
    // Making sure we have at least one node selected
    if (Object.keys(selected).length > 0) {
      var toKeep = nodesToKeep(s, selected);

      setSelectedColor(s, selected, toKeep);
      // Grey out irrelevant edges 
      setEdgesToInactive(s, toKeep);
    } else { // If no nodes are selected after click we just reset the graph
      resetStates(s);
    }
    showSelectedNodes(selected);
    s.refresh();
  }

  // Highlight hovered node and relevant nodes by greying out all else
  function nodeHover(s, node, selected) {
    var selectedAndHovered = [];
    // Make a copy of selected and add the hovered node
    Object.assign(selectedAndHovered, selected);
    selectedAndHovered[node.id] = node;
    var toKeep = nodesToKeep(s, selectedAndHovered);

    s.graph.nodes().forEach(function (n) {
      if (toKeep[n.id]) {
        n.color = n.originalColor;
      } else {
        n.color = '#eee';
      }
    });
    // Grey out irrelevant edges 
    setEdgesToInactive(s, toKeep);
    s.refresh();
  }

  // Return graph to pre-hover state
  function nodeHoverOut() {
    // Start clean, and then figure out what needs to be greyed out according to selected nodes
    resetStates(s);

    if (Object.keys(selected).length > 0) {
      var toKeep = nodesToKeep(s, selected);

      setSelectedColor(s, selected, toKeep);
      setEdgesToInactive(s, toKeep);
    }
    s.refresh();
  }

  // Reset all selections
  function resetStates(s) {
    s.graph.nodes().forEach(function (n) {
      n.color = n.originalColor;
    });
    s.graph.edges().forEach(function (e) {
      e.color = e.originalColor;
    });
  }

  // Return matching items from two arrays
  function returnMatchingArrayItems(array1, array2) {
    retain = [];

    for (var i = 0; i < array1.length; i += 1) {
      if (array2.indexOf(array1[i]) > -1) {
        retain.push(array1[i]);
      }
    }
    return retain;
  }

  // Return matching nodes from two arrays - 
  // for instance when two nodes are selected only common neighbors should be shown
  function returnMatchingNodes(array1, array2) {
    var retainKeys = returnMatchingArrayItems(Object.keys(array1), Object.keys(array2)),
      retainNodes = [];

    for (let id of retainKeys) {
      retainNodes[id] = array1[id];
    }
    return retainNodes;
  }

  // Return all relevant nodes to be kept
  function nodesToKeep(s, selected) {
    // Make sure selected is not empty when calling this
    var toKeep,
      i = 0;

    Object.keys(selected).forEach(function (key) {
      if (i == 0) {
        toKeep = s.graph.neighbors(key);
        toKeep[key] = selected[key];
      } else {
        var keep = s.graph.neighbors(key);
        keep[key] = selected[key];
        toKeep = returnMatchingNodes(toKeep, keep);
      }
      i++;
    });
    return toKeep;
  }

  // Set the color of all selected nodes
  function setSelectedColor(s, selected, toKeep) {
    s.graph.nodes().forEach(function (n) {

      if (selected[n.id]) {
        n.color = "#d9534f";
      }
      else if (!toKeep[n.id]) {
        n.color = '#eee';
        n.label = "";
      }
    });
  }

  // Grey out all edges that are not bewteen active nodes
  function setEdgesToInactive(s, nodesToKeep) {
    s.graph.edges().forEach(function (e) {
      if (nodesToKeep[e.source] && nodesToKeep[e.target]) {
        e.color = e.originalColor;
      } else {
        e.color = "#FFF" //e.inactiveColor;
      }
    });
  }
</script>
